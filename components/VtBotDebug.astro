---
import VtBotDebug1 from './VtBotDebug1.astro';
export interface Props {
	production?: boolean;
}
const TAG = 'vtbot-debug';
const { production = false } = Astro.props;
const active = import.meta.env.DEV || production;
---

{active && <meta name={TAG} content="true" />}

{active && <VtBotDebug1 />}
<script>
	// start of "late" part in (defered loaded) module script
	import {
		TRANSITION_AFTER_PREPARATION,
		TRANSITION_AFTER_SWAP,
		TRANSITION_BEFORE_PREPARATION,
		TRANSITION_BEFORE_SWAP,
		TRANSITION_PAGE_LOAD,
		isTransitionBeforePreparationEvent,
		isTransitionBeforeSwapEvent,
		supportsViewTransitions,
		type TransitionBeforePreparationEvent,
		type TransitionBeforeSwapEvent,
	} from 'astro:transitions/client';
	import { elementsWithStyleProperty } from './css';
	import { deriveCSSSelector } from './derive-css-selector';
	import * as prefix from './prefix';

	prefix.init('[vtbot-debug]', 'color: #48f');
	const enabled = () => !!document.querySelector('meta[name="vtbot-debug"]');

	/*
	 * address/content surrogate
	 */
	let addressCounter = 0;
	const mem = new WeakMap();
	const doc = (obj: Document) => {
		const units = ['B', 'kB', 'MB'];
		const humanReadable = (n: number) => {
			let i = 0;
			while ((n /= 1024) > 1 && i++ < units.length);
			return `${(n * 1024).toFixed(1)} ${units[i]}`;
		};
		const a = mem.get(obj) ?? `${++addressCounter}`;
		const html = obj.documentElement.outerHTML;
		mem.set(obj, a);
		return `@${a} (${humanReadable(html.length)})`;
	};

	const logWithStyle = (s: string, usePrefix = false) => {
		// @ts-ignore
		const _vtbot_debug = window._vtbot_debug;
		const css: string[] = [];
		s = s.replaceAll('**', '%c');
		const count = (s.match(/%c/g) || []).length / 2;
		for (let i = 0; i < count; i++) {
			css.push('display: inline-block; border: dotted 1pt gray; padding: 0 4pt;font-weight: 800');
			css.push('font-weight: normal');
		}
		(usePrefix ? prefix : console).log(s, ...css);
	};

	/*
	 * log a property of the event
	 */
	async function delta(e: Record<string, any>, prop: string, deltaOnly = false) {
		// @ts-ignore
		const _vtbot_debug = window._vtbot_debug;
		let bold = (s: string) => `**${s}**`;
		let deref = (x: any) => x;
		let print = (x: any) => x;
		let value = (x: any) => x;

		if (prop === 'to' || prop === 'from') {
			deref = (x) => x?.href;
			print = deref;
		} else if (prop === 'newDocument') {
			print = doc;
			value = doc;
		} else if (prop === 'swap' || prop === 'loader') {
			print = (x) => (x ? x.toString() : '(null)');
			bold = (x) => x + '\n';
		}

		let different = () => value(deref(_vtbot_debug.capture[prop])) !== value(deref(e[prop]));

		if (different()) {
			logWithStyle(
				`${prop} changed from ${bold(print(_vtbot_debug.capture[prop]))} to ${bold(print(e[prop]))}`,
				deltaOnly
			);
		} else if (!deltaOnly) {
			logWithStyle(`${prop}: ${bold(print(e[prop]))}`);
		}
	}

	/*
	 * Capture the event properties
	 */
	const doCapture = (e: Event) => {
		// @ts-ignore
		window._vtbot_debug.capture = {
			...e,
			type: e.type,
			cancelable: e.cancelable,
			defaultPrevented: e.defaultPrevented,
			event: e,
		};
	};

	/*
	 * log the properties of the event
	 */
	function logProperties(
		e: TransitionBeforePreparationEvent | TransitionBeforeSwapEvent,
		deltaOnly = false
	) {
		delta(e, 'type', deltaOnly);
		delta(e, 'cancelable', deltaOnly);
		delta(e, 'defaultPrevented', deltaOnly);
		delta(e, 'from', deltaOnly);
		delta(e, 'to', deltaOnly);
		delta(e, 'direction', deltaOnly);
		delta(e, 'navigationType', deltaOnly);
		delta(e, 'info', deltaOnly);
		delta(e, 'newDocument', deltaOnly);
		if (isTransitionBeforePreparationEvent(e)) {
			delta(e, 'formData', deltaOnly);
			delta(e, 'loader', deltaOnly);
		}
		if (isTransitionBeforeSwapEvent(e)) {
			delta(e, 'swap', deltaOnly);
		}
		doCapture(e);
	}

	/*
	 * Log beforePreparation
	 */
	function beforePreparation(preparationEvent: Event) {
		if (enabled()) {
			if (isTransitionBeforePreparationEvent(preparationEvent)) {
				prefix.groupCollapsed(`Properties of the ${preparationEvent.type} event`);
				logProperties(preparationEvent);
				console.groupEnd();
				const originalLoader = preparationEvent.loader;
				preparationEvent.loader = async () => {
					prefix.log(`before execution of loader()`);
					await originalLoader();
					logProperties(preparationEvent, true);
					prefix.log(`after execution of loader()`);
				};
				doCapture(preparationEvent);
			} else {
				console.log('not a TransitionBeforePreparationEvent');
			}
		}
	}

	const toCSSSelectorMap = (map: Map<string, Set<Element>> | undefined, where: string) => {
		const result = new Map<string, string>();
		if (map) {
			map.forEach((set, key) => {
				if (set.size === 1) {
					result.set(key, deriveCSSSelector([...set][0]));
				} else if (supportsViewTransitions && (set?.size ?? 0) > 1) {
					prefix.log(`view-transition-name ${key} is not unique in ${where} document\n`);
				}
			});
		}
		return result;
	};
	const logTransitions = (
		originalMap: Map<string, string> | undefined,
		swapEvent: TransitionBeforeSwapEvent
	) => {
		if (originalMap === undefined) return;

		// @ts-ignore
		const bold = (s: string) => `**${s}**`;
		const map = elementsWithStyleProperty('view-transition-name');
		map.set('root', (map.get('root') ?? new Set()).add(document.documentElement));
		const newMap = toCSSSelectorMap(map, 'new');
		let i = 0;

		prefix.groupCollapsed(
			`Transitions from ${swapEvent.from.pathname} to ${swapEvent.to.pathname}`
		);
		new Set([...originalMap.keys(), ...newMap.keys()]).forEach((name) => {
			const oldSelector = originalMap.get(name);
			const newSelector = newMap.get(name);

			logWithStyle(
				`[ transition] ${++i} "${bold(name)}" from ${bold(
					oldSelector ?? '(nowhere)'
				)} --to-> ${bold(newSelector ?? '(nowhere)')}`
			);
		});

		console.groupEnd();
	};

	const knownModuleScripts = new Set();
	const recordScripts = () =>
		[...document.scripts].forEach(
			(script) => script.type === 'module' && script.src && knownModuleScripts.add(script.src)
		);

	function logScripts() {
		const scripts = document.scripts;
		const nScripts = scripts.length;
		if (nScripts === 0) return;
		const scriptsArray = [...scripts];
		const toExecute = scriptsArray.filter(
			(s) =>
				s.dataset.astroExec !== '' &&
				(!s.type || s.type === 'module' || s.type === 'text/javascript') &&
				(s.type !== 'module' || !knownModuleScripts.has(s.src))
		);
		let i = 0;
		if (toExecute.length > 0) {
			prefix.groupCollapsed(
				`Scripts that will be executed between astro:after-swap and astro:page-load: (${toExecute.length})`
			);
			toExecute.forEach((script) => {
				i = logScript(script, i);
			});
			console.groupEnd();
		}
		if (nScripts > toExecute.length) {
			prefix.groupCollapsed(`Scripts that will NOT be executed: (${nScripts - toExecute.length})`);
			scriptsArray.forEach((script) => {
				if (!toExecute.includes(script)) {
					i = logScript(script, i);
				}
			});
			console.groupEnd();
		}

		function logScript(script: HTMLScriptElement, i: number) {
			script.type === 'module' && script.src && knownModuleScripts.add(script.src);
			let s = `${++i}. `;
			for (const attribute of script.attributes) {
				s += `${attribute.name}="${attribute.value}" `;
			}
			if (script.src) {
				console.log(s);
			} else {
				console.groupCollapsed(s);
				console.log(script.textContent ?? '');
				console.groupEnd();
			}
			return i;
		}
	}

	/*
	 * Log swap
	 */
	function beforeSwap(swapEvent: Event) {
		if (enabled()) {
			recordScripts();
			if (isTransitionBeforeSwapEvent(swapEvent)) {
				prefix.groupCollapsed(`Properties of the ${swapEvent.type} event`);
				logProperties(swapEvent);
				console.groupEnd();

				if (supportsViewTransitions) {
					const map = elementsWithStyleProperty('view-transition-name');
					map.set('root', (map.get('root') ?? new Set()).add(document.documentElement));
					// @ts-ignore
					window._vtbot_debug.originalMap = toCSSSelectorMap(map, 'old');
				}
				const originalSwap = swapEvent.swap;
				swapEvent.swap = async () => {
					prefix.log(`before execution of swap()`);
					originalSwap();
					// @ts-ignore
					logProperties(window._vtbot_debug.capture.event, true);
					prefix.log(`after execution of swap()`);
					prefix.log(`%o`, document.documentElement);
					// @ts-ignore
					window._vtbot_debug.savedSwapEvent = swapEvent;
				};
				doCapture(swapEvent);
				swapEvent.viewTransition.updateCallbackDone.then(
					() => prefix.log(`resolve viewTransition.updateCallbackDone`),
					(error: any) => prefix.log(`reject viewTransition.updateCallbackDone with`, error)
				);
				swapEvent.viewTransition.ready.then(
					() => prefix.log(`resolve viewTransition.ready`),
					(error: any) => prefix.log(`reject viewTransition.ready with`, error)
				);
				swapEvent.viewTransition.finished.then(
					() => {
						prefix.log(`resolve viewTransition.finished`);
					},
					(error: any) => {
						prefix.log(`reject viewTransition.finished with`, error);
					}
				);
			} else {
				console.log('not a TransitionBeforeSwapEvent');
			}
		}
	}

	const afterSwap = (e: Event) => {
		if (enabled()) {
			// @ts-ignore
			const event = window._vtbot_debug.capture.event;
			logProperties(event, true);
			prefix.log(`Event handler for ${e.type}`);
			// @ts-ignore
			const _vtbot_debug = window._vtbot_debug;
			if (supportsViewTransitions) {
				logTransitions(_vtbot_debug.originalMap, _vtbot_debug.savedSwapEvent);
			} else {
				prefix.log(`morphing transitions are not supported by this browser`);
			}
			logScripts();
		}
	};

	/*
	 * Register the "late" handlers
	 */
	// register as late as possible (= in pageshow event) to be the last handler in the chain
	window.addEventListener('pageshow', () => {
		let beginning = 0;

		prefix.log(
			`Registering event listeners for '${TRANSITION_BEFORE_PREPARATION}', '${TRANSITION_AFTER_PREPARATION}', '${TRANSITION_BEFORE_SWAP}', '${TRANSITION_AFTER_SWAP}' and '${TRANSITION_PAGE_LOAD}'`
		);
		document.addEventListener(TRANSITION_BEFORE_PREPARATION, beforePreparation);
		document.addEventListener(TRANSITION_AFTER_PREPARATION, (e) => {
			if (enabled()) {
				// @ts-ignore
				logProperties(window._vtbot_debug.capture.event, true);
				prefix.log(`Event handler for ${e.type}`);
			}
		});
		document.addEventListener(TRANSITION_BEFORE_SWAP, beforeSwap);
		document.addEventListener(TRANSITION_AFTER_SWAP, afterSwap);
		document.addEventListener(TRANSITION_PAGE_LOAD, (e) => {
			if (enabled()) {
				// @ts-ignore
				logProperties(window._vtbot_debug.capture.event, true);
				prefix.log(`Event handler for ${e.type}`);
				beginning = 0;
			}
		});
		/*
		document.addEventListener('animationstart', (e) => {
			beginning ??= e.timeStamp;
			if (enabled() && e instanceof AnimationEvent) {
				console.log(
					`${PREFIX} ${e.timeStamp-beginning} ${e.pseudoElement} started ${e.animationName}`
				);
			}
		});
		document.addEventListener('animationend', (e) => {
			if (enabled()) {
				console.log(
					`${PREFIX} ${e.timeStamp-beginning} ${e.pseudoElement} ended ${e.animationName}`
				);
			}
		});
	*/
	});
</script>
